Linker Overview
                              Linker Overview

-  The primary purpose of a linker is to produce an file which can be executed
   by an operating system.

-  In DOS, executable files come in three flavors:

                       	  "EXE" files
                       	  "COM" files
                       	  "SYS" files

-  The input to the linker comes from module(s) called translator modules.

-  Individual translator modules can be stored in "OBJ" files.  "OBJ" files
   are produce by language translators such as assemblers and compilers.

-  Libraries of translator modules can be stored in "LIB" files which are
   produced by a librarian from either "OBJ" files or other "LIB" files.

-  A linker can process translator modules from either "OBJ" or "LIB" files,
   but at least one module must have come from an "OBJ" file.

-  All translator modules from "OBJ" files will be included in the executable
   file, but only modules which resolve externals come from "LIB" files.
Comparison of Executable Files (1 of 2)
                        Comparison of Executable Files

-  "EXE" files have a header which contains relocation and other information
   which permit "EXE" files to have multiple segments.  This header sets "EXE"
   files apart from the other executable file types.  Programs are written
   starting at address 0 (relative to where the program is loaded in memory).

-  "COM" files have no header.  "COM" files are written starting a address 100H
   because the "COM" file is loaded immediately after the program segment prefix
   (PSP) which is 100H bytes long.  At the start of the program, the CS and DS
   segment registers point to the PSP.  "EXE" files which have an empty
   relocation table can be converted to "COM" files by the "EXE2BIN" program.

-  "SYS" files are more closely related to "COM" files than "EXE" files.  "SYS"
   files are loaded once at DOS initialization time.  Since there is no PSP,
   the programs are written starting at address 0.  However, like "COM" files,
   "SYS" files must have an empty relocation table.
Comparison of Executable Files (2 of 2)
                         Contents of Executable Files



    "EXE" files                                      "SYS" files
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                                ÚÄÄÄÄÄÄÄÄÄÄÄ¿
³   "EXE" header   ³                                ³load moduleÃÄÄ¿
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                                ÀÄÄÄÄÄÄÄÄÄÄÄÙ  ³
³ relocation table ³                                               ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                    ÚÄÄÄÄÄ¿                    ³
³   load module    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´org 0ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                    ÀÄÄÄÄÄÙ



                        "COM" files
                       ÚÄÄÄÄÄÄÄÄÄÄÄ¿                 ÚÄÄÄÄÄÄÄÄ¿
                       ³load moduleÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´org 100H³
                       ÀÄÄÄÄÄÄÄÄÄÄÄÙ                 ÀÄÄÄÄÄÄÄÄÙ


-  Each of the above contents are described in detail in the following slides.

"EXE" File Header (1 of 2)
                              "EXE" File Header
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Offset³                           Description                                 ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³00-01 ³ The "EXE" file signature 4D5AH.                                       ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³02-03 ³ Length of the "EXE" file modulo 512.                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³04-05 ³ Number of 512-byte pages.  If the last page is not full it is still   ³
³      ³ included in the count.                                                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³06-07 ³ Number of relocation items.                                           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³08-09 ³ Number of 16-byte paragraphs occupied by "EXE" header and relo table. ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0A-0B ³ Number of paragraphs required immediately after load module.  The     ³
³      ³ linker computes the number of uninitialized bytes at the end of the   ³
³      ³ load module.  Instead of writing these bytes to the "EXE" file, the   ³
³      ³ linker sets this value to provide space for this data.                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0C-0D ³ Maximum number of paragraphs which may be required immediately after  ³
³      ³ the "EXE" file.  This value comes from the CPARMAXALLOC switch.       ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Note:  The "EXE" file header routines are in "EXECFILE.C" (handout page 9)
"EXE" File Header (2 of 2)
                              "EXE" File Header
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Offset³                           Description                                 ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0E-11 ³ Offset/Segment displacement into the load module of the initial SP/SS.³
³      ³ The displacement is converted to an actual address by adding the base ³
³      ³ address of the load module.  Since there may be several stack segments³
³      ³ in the translator modules, the linker uses the highest address of the ³
³      ³ largest segment with the stack attribute.                             ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³12-13 ³ Word checksum computed as minus the sum of all the words in the file. ³
³      ³ Overflows are ignored.  DOS will not validate the checksum if this    ³
³      ³ value is set to zero                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³14-17 ³ Offset/Segment displacement into the load module of the initial IP/CS.³
³      ³ The displacement is converted to an actual address by adding the base ³
³      ³ address of the load module.                                           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³18-19 ³ Length of "EXE" file header.  (Used to find beginning of relo table.) ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1A-1B ³ Overlay number.  This is zero for the main program.                   ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1C-1D ³ Always 0001H.                                                         ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Relocation Table
                               Relocation Table

The number of relocation items is specified at offset 06-07 in the "EXE" file
header.  The offset of the relocation table is located at offset 18-19 in the
"EXE" file header.  Usually this value is 001EH, but can be larger if the "EXE"
file header has been extended.

The relocation table can be viewed as an array of Offset/Segment displacements
into the load module.  For each address, the segment portion of the base address
of the load module is added to the word at that displacement.  The only time a
relocation item is needed is when a fixup involves a segment.  As we will see
later, this can only be caused by base and pointer type fixups.

As an example of a how a relocation item is generated, consider the following:

                           foo      db      'a'
                           bar      dd      foo

Note that the contents of "bar" is the address of "foo", but the actual address
of "foo" is not known until the program is loaded in memory.  All that is known
at link time is how far (i.e., the displacement) into the load module "foo" and
"bar" are located.  Only the displacement of "foo" is stored at link time.  But,
the linker makes a relocation entry showing that "bar"+2 must be relocated.
Load Module
                                 Load Module

By far, the generation of the load module is the trickest part of producing an
executable file.  The contents of the load module is generated from the contents
of translator modules stored in "OBJ" and "LIB" files.  Much of the structure
of translator modules comes from the assembler directives.  In turn, those
directives are related to the architecture of the 80x86 family of micros.

Here are some of the important directives:

SEGMENT/ENDS is used to give a logical name along with grouping and combining
     information for the segments.  The linker is responsible for arranging and
     combining these logical segments into the physical segments which comprise
     a load module.

EXTRN/PUBLIC is used access data across translator modules.

A detailed description of the format of translator modules follows.
Terminology and Abbreviations
                         Terminology and Abbreviations

MAS - Memory Address Space:  The memory capable of being addressed by the
    hardware architecture.

T-MODULE - Translator Module:  This is a unit of object code produced by a
    language translator.  They may be stored individually in "OBJ" files or
    collections may be stored in "LIB" files.

FRAME:  A contiguous 64K chunk of MAS.

FRAME NUMBER:  Paragraph number where a FRAME begins.

CANONIC FRAME:  For the 8086, each byte of memory is encompassed by up to
    4096 FRAMEs.  The CANONIC FRAME frame is lowest FRAME NUMBER which
    encompasses that byte.

LSEG - Logical Segment:  Data and code between SEGMENT - ENDS directives.

PSEG - Physical Segment:  A collection of one or more LSEGs placed into a
    load module.
Fixup Overview
                                Fixup Overview

Not all references to MAS can be resolved at translation time.  This can happen
when one T-MODULE must access data located in another T-MODULE.  When this
happens, the language translator places an entry in the T-MODULE so that the
linker can complete the address reference.  Such entries in a T-MODULE are
called "Fixups".

In order for the linker to complete the address reference, it needs five pieces
of information:

     	  The LOCATION in memory where the reference occurs.  This is the address
        which must be fixed up.

     	  The type of LOCATION in memory where the reference occurs.

     	  Whether the fixup is relative to the IP or not.  This is refered to
        as the fixup MODE.

     	  The TARGET address which LOCATION is referencing.

     	  The FRAME number in the segment register used to reference the TARGET
        address.
LOCATION Types
                                LOCATION Types

There are five types of LOCATIONs.  They are POINTER, BASE, OFFSET, HIBYTE,
and LOBYTE.  The relative position and length of each LOCATION type from a
LOCATION, X is given below:

                 ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
                 ³   X+0    ³   X+1    ³   X+2    ³   X+3    ³
                 ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ

                 ÃÄÄLOBYTEÄÄ´

                            ÃÄÄHIBYTEÄÄ´

                 ÃÄÄÄÄÄÄÄOFFSETÄÄÄÄÄÄÄÄ´

                                       ÃÄÄÄÄÄÄÄÄBASEÄÄÄÄÄÄÄÄÄ´

                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPOINTERÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
Fixup Modes
                                 Fixup Modes

There are two fixup modes.  Both modes stem from the architecture of the 80x86
microprocessor family.  The TARGET may be addressed directly via the
offset/segment mechanism.  This fixup mode is called "segment-relative".

The other manner a TARGET may be addressed is relative to the IP.  For example,
the TARGET of the 80x86 jump instructions (e.g., JE, JC, JA, etc) are all
relative to the IP.  This fixup mode is called "self-relative".  Note that
the self-relative mode is relative to the value of the IP when the instruction
executes.  In all cases, the IP points to the first byte of the instruction
following the one being executed.
TARGET (1 of 3)
                                    TARGET

The TARGET is the location in MAS being referenced by LOCATION.  There are
four basic ways of specifying the TARGET.  The four methods of specifying
a TARGET are:

         	  TARGET is specified relative to an LSEG.
         	  TARGET is specified relative to a group.
         	  TARGET is specified relative to an external symbol.
         	  TARGET is specified relative to an absolute FRAME.

The four primary methods specify a displacement while the four secondary
methods do not specify a displacement (because the displacement is 0).
TARGET (2 of 3) -- Primary TARGET Methods
                            Primary TARGET Methods
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³       Notation          ³               Description                   ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T0  ³SI(segment),displacement ³The TARGET is at the specified displacement  ³
³      ³                         ³in the LSEG segment.                         ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T1  ³GI(group),displacement   ³The TARGET is at the specified displacement  ³
³      ³                         ³in the group.                                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T2  ³EI(external),displacement³The TARGET is at the specified displacement  ³
³      ³                         ³past the external.                           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T3  ³FR(frame),displacement   ³The TARGET is at the specified displacement  ³
³      ³                         ³past the FRAME NUMBER frame.                 ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Example:

SI(foo),4 means the TARGET is 4 bytes into the LSEG foo.  Several T-MODULES
could have an LSEG named foo which may be combined into a PSEG foo.  So, the
final displacement in the PSEG foo may not be 4.  The linker must take this
into consideration.
TARGET (3 of 3) -- Secondary TARGET Methods
                           Secondary TARGET Methods

      ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      ³Method³ Notation   ³               Description                   ³
      ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
      ³  T4  ³SI(segment) ³The TARGET is the base of the LSEG segment.  ³
      ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
      ³  T5  ³GI(group)   ³The TARGET is the base of the group.         ³
      ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
      ³  T6  ³EI(external)³The TARGET is the specified external.        ³
      ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
      ³  T7  ³FR(frame)   ³The TARGET is the specified frame.           ³
      ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
FRAME (1 of 5)
                                      FRAME
 
The FRAME portion of a fixup specifies the FRAME NUMBER that will be used as the
frame of reference for LOCATION's reference to TARGET.  Typically, this frame of
reference is one of the segment registers.  The FRAME NUMBER in the segment
register is specified via the assembler "ASSUME" directive.

Even if the fixup is self-relative, the TARGET must still be in the FRAME given
by the FRAME NUMBER in the segment register.  So, a FRAME is required for both
segment-relative fixups and self-relative fixups.

There are seven methods of specifying a FRAME:

                            	 A segment
                            	 A group
                            	 An external
                            	 An absolute FRAME NUMBER
                            	 LOCATION's FRAME
                            	 TARGET's FRAME
                            	 No FRAME specified
FRAME (2 of 5) -- FRAME Methods F0 thru F3
                                  FRAME Methods

ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³                          Description                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F0  ³The FRAME for the fixup is the CANONIC FRAME of the PSEG containing the³
³      ³LSEG.  (Since the fixup is generated at translation time, an LSEG is   ³
³      ³specified.)                                                            ³
³      ³Notation:  EI(segment)                                                 ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F1  ³The FRAME for the fixup is the CANONIC FRAME of the PSEG located lowest³
³      ³in MAS.  A group is specified.                                         ³
³      ³Notation:  GI(group)                                                   ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F2  ³The FRAME for the fixup is specified by an external.  Typically, the   ³
³      ³external is located in a T-MODULE different from the T-MODULE          ³
³      ³generating the fixup.                                                  ³
³      ³Notation:  EI(external)                                                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F3  ³The absolute FRAME number is specified.                                ³
³      ³Notation:  FR(FRAME)                                                   ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
FRAME (3 of 5) -- FRAME Methods F4 thru F6
                                  FRAME Methods

ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³                          Description                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F4  ³The FRAME is the CANONIC FRAME of the PSEG containing LOCATION.        ³
³      ³Notation:  LOCATION                                                    ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5  ³The FRAME is determined by the TARGET.  Notation:  TARGET              ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F6  ³No frame of reference specified.  Notation:  NONE                      ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
FRAME (4 of 5) -- FRAME Method F2 cases
                              FRAME Method F2 cases

When FRAME method F2 is specified (FRAME is specified by an external), there
are three cases depending on how the external is defined:

ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³                          Description                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F2a ³If the external is defined relative to an LSEG which is not in a group ³
³      ³then the FRAME is the CANONIC FRAME of the PSEG containing the LSEG.   ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F2b ³If the external is defined absolutely and not in a group, then the     ³
³      ³FRAME is the CANONIC FRAME of the external.                            ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³  F2c ³If the external is associated with a group, the FRAME is the CANONIC   ³
³      ³FRAME of the PSEG in the group with the lowest MAS.                    ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
FRAME (5 of 5) -- FRAME Method F5 cases
                              FRAME Method F5 cases

When FRAME method F2 is specified (FRAME is specified by the TARGET), there are
four cases depending on how the TARGET was specified:

ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³                          Description                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5a ³If the TARGET method is T0 or T4, then FRAME is the CANONIC FRAME of   ³
³      ³PSEG containing TARGET.                                                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5b ³If the TARGET method is T1 or T5, then FRAME is the CANONIC FRAME of   ³
³      ³PSEG in the same group as TARGET and with the lowest MAS.              ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5c ³If the TARGET method is T2 or T6, then the FRAME is determined by the  ³
³      ³rules given in FRAME method F2.                                        ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5d ³If the TARGET method is T3 or T7, then the FRAME is the FRAME NUMBER   ³
³      ³specified by the TARGET.                                               ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Performing a Fixup (1 of 3)
                               Performing a Fixup

Regardless of the fixup mode (segment-relative or self-relative), the first
step in performing a fixup is to insure that the TARGET is addressable
given the FRAME of reference.  That is, the TARGET must lie between FRAME
and FRAME+65535 inclusive.

                          FRAME ó TARGET ó FRAME+65535

If this is not the case, a warning is given.

After verifying that TARGET can be addressed by FRAME, how a fixup is performed
depends of the FIXUP mode.

Performing a Fixup (2 of 3) -- Self-Relative Fixups
                              Self-Relative Fixups

Self-relative fixups are permitted for LOBYTE and OFFSET type LOCATIONs only.
If the LOCATION type is HIBYTE, BASE, or POINTER, no fixup is performed and an
error message is given.

For self-relative fixups, the value of the PC (CS:IP) when the instruction is
executed must be determined.  Then, the DISTANCE to the TARGET from the PC is 
computed.  The formulae for DISTANCE and PC are given below:

                     PC = LOCATION + 1 (If LOCATION type is LOBYTE)
                     PC = LOCATION + 2 (If LOCATION type is OFFSET)
                     DISTANCE = TARGET - PC

For LOBYTE locations, an error is issued when DISTANCE falls outside of
-128 ó DISTANCE ó 127.

The fixup is performed by adding DISTANCE to LOCATION.  For LOBYTE LOCATIONs,
DISTANCE is added modulo 256.  For OFFSET LOCATIONs, DISTANCE is added
modulo 65536.
Performing a Fixup (3 of 3) -- Segment-Relative Fixups
                             Segment-Relative Fixups

For segment-relative fixups, DISTANCE = TARGET - FRAME.  If DISTANCE falls
outside of 0 ó DISTANCE ó 65535, a warning is issued.  The following table
gives how to perform the fixup depending on LOCATION type:
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³LOCATION³                            Action                                   ³
³  type  ³                                                                     ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³LOBYTE  ³DISTANCE is added (modulo 256) to the low order byte at LOCATION.    ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³HIBYTE  ³DISTANCE is added (modulo 256) to the high order byte at LOCATION.   ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³OFFSET  ³DISTANCE is added (modulo 65536) to the word at LOCATION.            ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³BASE    ³FRAME is added (modulo 65536) to the word at LOCATION.               ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³POINTER ³DISTANCE is added (modulo 65536) the low order word at LOCATION.     ³
³        ³A relocation item for the word at LOCATION is created.               ³
³        ³FRAME is added (modulo 65536) to the high order word of the DWORD at ³
³        ³LOCATION.  A relocation item for the high order word of the DWORD at ³
³        ³LOCATION is created.                                                 ³
ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
T-MODULE Record Format (1 of 38) -- Basics
                          T-MODULE Record Format Basics

All T-MODULE records have the following basic format:

                       ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                       ³Record³ Record³Information Specific³Check³
  Field NamesÄÄÄÄÄÄÄÄÄ>³ Type ³ Length³   to Record Type   ³ Sum ³
                       ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
  Field LengthsÄÄÄÄÄÄÄ>³  1   ³   2   ³  Record Length - 1 ³  1  ³
     (bytes)           ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Record Type --
  This one byte field identifies the type of T-MODULE record.

Record Length -- 
  This word contains the number of bytes in all following fields (including
  the checksum).

Information Specific to Record Type --
  This field contains the data for the specified Record Type.
 
Check Sum --
  This byte contains the negative of the sum of all the preceding bytes in the
  record.  Therefore, the sum of all the bytes in the record will be 0.
T-MODULE Record Format (2 of 38) -- Bit Fields
                      T-MODULE Record Format -- Bit Fields

Bit fields are denoted as follows:

                               ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                               ³ Bit ³ Bit ³ Bit ³
        Field NameÄÄÄÄÄÄÄÄÄÄÄÄ>³Field³Field³Field³
                               ³  1  ³  2  ³  n  ³
                               ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
        Field LengthÄÄÄÄÄÄÄÄÄÄ>³  4  ³  1  ³  3  ³
           (bits)              ÃÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄ´
                               ³      byte       ³
                               ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
T-MODULE Record Format (3 of 38) -- INDEX Fields
                     T-MODULE Record Format -- INDEX Fields

There are three special kinds of fields in a T-MODULE record:

"INDEX" fields:
                       ÚÄÄÄÄÄ¿
                       ³INDEX³
                       ÃÄÄÄÄÄ´
                       ³ 1-2 ³
                       ÀÄÄÄÄÄÙ

An INDEX field is one or two bytes long.  If the high order bit of the first
byte of the INDEX is 0, then the INDEX is one byte long and the value is the
remaining 7 bits (0 - 127).  Otherwise, the INDEX is two bytes long and the
value of the INDEX is the low order 7 bits of the first byte * 256 plus
the second byte.
T-MODULE Record Format (4 of 38) -- NAME Fields
                      T-MODULE Record Format -- NAME Fields


The format of a "NAME" field is:

                              ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿
                              ³ NAME ³   NAME    ³
                              ³Length³           ³
                              ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄ´
                              ³  1   ³NAME Length³
                              ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÙ

Note:  NAMEs of 0 bytes are permitted.  The NAME is not NULL terminated.
T-MODULE Record Format (5 of 38) -- VALUE Fields
                     T-MODULE Record Format -- VALUE Fields

The format of "VALUE" fields is:

                               ÚÄÄÄÄÂÄÄÄÄÄÄ¿
                               ³Code³Number³
                               ÃÄÄÄÄÅÄÄÄÄÄÄ´
                               ³ 1  ³ 0-4  ³
                               ÀÄÄÄÄÁÄÄÄÄÄÄÙ

When 0 ó Code ó 128, the Number field is omitted and the VALUE is Code.

When Code = 129, the Number field is 2 bytes long, and the VALUE is Number.

When Code = 132, the Number field is 3 bytes long, and the VALUE is Number.

When Code = 136, the Number field is 4 bytes long, and the VALUE is Number.
T-MODULE Record Format (6 of 38) -- T-MODULE Header
                    T-MODULE Record Format -- T-MODULE Header

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³T-MODULE NAME³Check³
                        ³80H³Length³             ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    NAME     ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

This record type must be the first record in the T-MODULE, and it names the
T-MODULE.  Frequently, the T-MODULE NAME is the name of the source file to
the language translator.
T-MODULE Record Format (7 of 38) -- List of NAMEs (LNAMEs)
                T-MODULE Record Format -- List of NAMEs (LNAMEs)
                  
                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³            ³Check³
                        ³96H³Length³Logical NAME³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    NAME    ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄÄrepeatedÄÄÙ

Each Logical NAME is entered into a "List of NAMES" (LNAME) in the order they
are encountered in type 96H records.  The list index starts at 1 (0 means not
specified).  There may be more than one type 96H record in a T-MODULE.  When
this occurs, append the Logical NAMEs to the list.  The Logical NAME field
is repeated.  The number of repetitions is determined by the Record Length.
T-MODULE Record Format (8 of 38) -- LSEG Definition (SEGDEF)
               T-MODULE Record Format -- LSEG Definition (SEGDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³ Segment ³Segment³Segment³Class³Overlay³Check³
           ³90H³Length³Attribute³Length ³ INDEX ³INDEX³ INDEX ³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³  1-4    ³  2    ³ INDEX ³INDEX³ INDEX ³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Segment Attribute:  ÚÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿  ACBP:  ÚÄÂÄÂÄÂÄ¿
                    ³ACBP³FRAME NUMBER³Offset³         ³A³C³B³P³
                    ÃÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´         ÃÄÅÄÅÄÅÄ´
                    ³ 1  ³     2      ³  1   ³         ³3³3³1³1³
                    ÀÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄ´         ÃÄÁÄÁÄÁÄ´
                         ÀÄÄÄÄconditionalÄÄÄÄÙ         ³  Byte ³
                                                       ÀÄÄÄÄÄÄÄÙ
                                                 Note:  ACBP.P must be 0.

There is one SEGDEF record for each LSEG in a T-MODULE.  Like the LNAME list,
this forms a list of LSEGs (indexed from 1).
T-MODULE Record Format (9 of 38) -- SEGDEF.ACBP.A
                     T-MODULE Record Format -- SEGDEF.ACBP.A

The following table gives the meaning of the A field of the ACBP field:

ÚÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³A³                             Description                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0³This is an absolute segment.  The FRAME NUMBER and Offset fields of the³
³ ³Segment Attribute field will be present.                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1³This is a relocatable, byte-aligned LSEG.                              ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³2³This is a relocatable, word-aligned LSEG.                              ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³2³This is a relocatable, paragraph-aligned LSEG.                         ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³4³This is a relocatable, page-aligned LSEG.                              ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³5³This is a relocatable, DWORD-aligned LSEG.                             ³
ÀÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
T-MODULE Record Format (10 of 38) -- SEGDEF.ACBP.C
                     T-MODULE Record Format -- SEGDEF.ACBP.C

The following table gives the meaning of the C field of the ACBP field:
ÚÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³C³                               Description                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0³The LSEG is private and may not be combined.                             ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1³Undefined.                                                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³2³The LSEG is public and may be combined with other LSEGs of the same name.³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³3³Undefined.                                                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³4³The LSEG is public and may be combined with other LSEGs of the same name.³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³5³The LSEG is a stack segment and may be combined with other LSEGs of the  ³
³ ³same name.                                                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³6³The LSEG is a common segment and must be combined with other LSEGs of the³
³ ³same name.                                                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³7³The LSEG is public and may be combined with other LSEGs of the same name.³
ÀÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
T-MODULE Record Format (11 of 38) -- Notes on Combining
                  T-MODULE Record Format -- Notes on Combining

LSEGs which can be combined and are not common are combined as follows:

                      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                      ³LSEG data for first T-MODULE     ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³Alignment Gap for second T-MODULE³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³LSEG data for second T-MODULE    ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³            ///                  ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³Alignment Gap for last T-MODULE  ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³LSEG data for last T-MODULE      ³
                      ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

The resultant PSEG is the combined length of the above.

For common LSEGs, the length of the PSEG is the length of the largest LSEG.
Therefore, the length of the PSEG cannot be determined until all the T-MODULEs
are processed.  For this reason, data cannot be loaded into common segments
until fixup time.
T-MODULE Record Format (12 of 38) -- LSEG Definition (SEGDEF)
               T-MODULE Record Format -- LSEG Definition (SEGDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³ Segment ³Segment³Segment³Class³Overlay³Check³
           ³90H³Length³Attribute³Length ³ INDEX ³INDEX³ INDEX ³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³  1-4    ³  2    ³ INDEX ³INDEX³ INDEX ³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Segment Length --
  If ACBP.B is 0, then this is the length of the LSEG.  If ACBP.B is 1, then the
  Segment Length must be 0 and the length of the LSEG is 65536 bytes.

Segment INDEX --
  This is an INDEX into the LNAME list.  LNAME[Segment INDEX] is the name of the
  LSEG.

Class INDEX --
  This is an INDEX into the LNAME list.  LNAME[Class INDEX] is the name of the
  LSEG.

Overlay INDEX --
  This is an INDEX into the LNAME list.  LNAME[Class INDEX] is the name of the
  LSEG.
T-MODULE Record Format (13 of 38) -- Group Definition (GRPDEF)
               T-MODULE Record Format -- Group Definition (GRPDEF)

                    ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                    ³   ³Record³Group NAME ³   ³LSEG ³Check³
                    ³9AH³Length³  INDEX    ³FFH³INDEX³ Sum ³
                    ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
                    ³ 1 ³  2   ³  INDEX    ³ 1 ³INDEX³  1  ³
                    ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄrepeatedÙ

Like the LNAME list and SEGDEF list, the GRPDEFs form a list (indexed relative
to 1) of groups.  The is one GRPDEF record for each group in the T-MODULE.

Group NAME INDEX --
  LNAME[Group NAME INDEX] is the name of the group.

LSEG INDEX --
  This field is repeated once for each LSEG in the group.  The LSEG INDEX is
  the INDEX into the LSEG list which corresponds to the LSEG in the group.
T-MODULE Record Format (14 of 38) -- Public Definition (PUBDEF)
              T-MODULE Record Format -- Public Definition (PUBDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³Group³Segment³FRAME ³Public³Public³Type ³Check³
           ³90H³Length³INDEX³ INDEX ³NUMBER³ NAME ³Offset³INDEX³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³INDEX³ INDEX ³ 0-2  ³ NAME ³  2   ³INDEX³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄÄÄÄÄrepeatedÄÄÄÄÄÄÙ

Group INDEX --
  If the public(s) are defined is an LSEG which is part of a group, then this is
  the index into the group list.

Segment INDEX --
  If the public(s) are defined in an LSEG, this is the index into the LSEG list.

FRAME NUMBER --
  This field is only present if the public(s) are absolute (indicated by both
  Group INDEX and Segment INDEX being zero).  When present, this is the FRAME
  NUMBER used to reference the public(s).
T-MODULE Record Format (15 of 38) -- Public Definition (PUBDEF)
              T-MODULE Record Format -- Public Definition (PUBDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³Group³Segment³FRAME ³Public³Public³Type ³Check³
           ³90H³Length³INDEX³ INDEX ³NUMBER³ NAME ³Offset³INDEX³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³INDEX³ INDEX ³ 0-2  ³ NAME ³  2   ³INDEX³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄÄÄÄÄrepeatedÄÄÄÄÄÄÙ

Public NAME --
  This is the name of the public.

Public Offset --
  This is the distance of the start of the public from the group, LSEG or FRAME.

Type INDEX --
  This is ignored.
T-MODULE Record Format (16 of 38) -- External Definition (EXTDEF)
              T-MODULE Record Format -- Public Definition (EXTDEF)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³External³Type ³Check³
                        ³BCH³Length³  NAME  ³INDEX³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³  NAME  ³INDEX³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄÄÄrepeatedÄÄÄÙ

Like the LNAMEs, SEGDEFs, and GRPDEFs, the EXTDEFs form a list (indexed relative
to 1) of the external names used in this T-MODULE.

External NAME --
  This is the name of the external public symbol.

Type INDEX --
  This is ignored.
T-MODULE Record Format (17 of 38) -- Logical Enumerated Data
           T-MODULE Record Format -- Logical Enumerated Data (LEDATA)
 
                   ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                   ³   ³Record³Segment³      ³        ³Check³
                   ³A0H³Length³ INDEX ³Offset³  Data  ³ Sum ³
                   ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                   ³ 1 ³  2   ³ INDEX ³  2   ³   1    ³  1  ³
                   ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                             ÀrepeatedÙ

Segment INDEX --
  This data is to be loaded into the LSEG corresponding to SEGDEF list entry
  SEGDEF[Segment INDEX].

Offset --
  This data is to be loaded starting at this offset in the LSEG.

Data --
  The byte(s) to be loaded.  No more than 1024 can be loaded by an LEDATA
  record.
T-MODULE Record Format (18 of 38) -- Logical Iterated Data
            T-MODULE Record Format -- Logical Iterated Data (LIDATA)
 
                  ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                  ³   ³Record³Segment³      ³ Iterated ³Check³
                  ³A2H³Length³ INDEX ³Offset³Data Block³ Sum ³
                  ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                  ³ 1 ³  2   ³ INDEX ³  2   ³ variable ³  1  ³
                  ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                            ÀÄrepeatedÄÙ

Segment INDEX --
  This data is to be loaded into the LSEG corresponding to SEGDEF list entry
  SEGDEF[Segment INDEX].

Offset --
  This data is to be loaded starting at this offset in the LSEG.

Iterated Data Block --
  This is (recursively) defined later, but the total size cannot exceed
  1024 bytes.
T-MODULE Record Format (19 of 38) -- Logical Iterated Data
            T-MODULE Record Format -- Logical Iterated Data (LIDATA)


Iterated Data Block:  ÚÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿
                      ³Repeat³Block³        ³
                      ³Count ³Count³ Content³
                      ÃÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄ´
                      ³  2   ³  2  ³variable³
                      ÀÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÙ

Repeat Count --
  If Block Count is zero then Content is interpreted as a string of bytes of
  length Repeat Count.  If Block Count is zero, then this is the number of times
  the Content field is repeated.

Block Count --
  If this is zero, then the Content field is interpreted as a string of bytes
  of length Repeat Count.  If this is non-zero, then the Content field contains
  a string of Block Count Iterated Data Blocks.

Content --
  This is either a string of bytes as described above or it is a string of
  Iterated Data Blocks.
T-MODULE Record Format (20 of 38) -- Fixup Record (FIXUPP)
                 T-MODULE Record Format -- Fixup Record (FIXUPP)

                           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                           ³   ³Record³ Thread ³Check³
                           ³9CH³Length³or Fixup³ Sum ³
                           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                           ³ 1 ³  2   ³variable³  1  ³
                           ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                      ÀrepeatedÙ

Thread or Fixup --
  This field can be either a Thread (high order bit is 0) or Fixup (high order
  bit is 1).  A Thread is a default TARGET or FRAME method.  There are four
  TARGET threads and four FRAME threads.  Thread fields are used to store the
  default TARGET or FRAME method.  A Fixup type field specifies the five
  pieces of information (discussed earlier) necessary to perform a fixup.
T-MODULE Record Format (21 of 38) -- Thread
                        T-MODULE Record Format -- Thread

Thread:  ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄ¿  Thread Data:  ÚÄÂÄÂÄÂÄÄÄÄÄÄÂÄÄÄÄÄ¿
         ³Thread³Thread ³                ³0³D³0³Method³Thred³
         ³ Data ³ INDEX ³                ÃÄÅÄÅÄÅÄÄÄÄÄÄÅÄÄÄÄÄ´
         ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄ´                ³1³1³1³  3   ³  2  ³
         ³  1   ³0-INDEX³                ÃÄÁÄÁÄÁÄÄÄÄÄÄÁÄÄÄÄÄ´
         ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÙ                ³       byte       ³
                                         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

D --
  If D is zero then a TARGET thread is being specified, otherwise a FRAME thread
  is being specified.

Method --
  This is the TARGET or FRAME method.  For TARGET threads, only the four primary
  methods are specified.  All seven FRAME methods can be specified.

Thred --
  This is the TARGET or FRAME thread number being specified.

Thread INDEX --
  This is not present when F4, F5 or F6 is being specified.  In all other cases,
  this is either a Segment, Group or External index depending on the Method.
T-MODULE Record Format (22 of 38) -- Fixup
                         T-MODULE Record Format -- Fixup

                    ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³LOCAT³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³     ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  2  ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

LOCAT:  ÚÄÂÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
        ³ ³    ³ ³LOCATION³LE/LIDATA³
        ³1³Mode³0³  Type  ³  Offset ³
        ÃÄÅÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
        ³1³ 1  ³1³   3    ³    10   ³
        ÃÄÁÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´
        ³low byte          high byte³ Note:  Low and high bytes are swapped.
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
         
Mode --
  If Mode is 0 then this is a self-relative fixup, otherwise it is a segment-
  relative fixup.  Self-relative fixups on LIDATA are not permitted.
T-MODULE Record Format (23 of 38) -- Fixup
                         T-MODULE Record Format -- Fixup

LOCAT:  ÚÄÂÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
        ³ ³    ³ ³LOCATION³LE/LIDATA³
        ³1³Mode³0³  Type  ³  Offset ³
        ÃÄÅÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
        ³1³ 1  ³1³   3    ³    10   ³
        ÃÄÁÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´
        ³low byte          high byte³
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

LOCATION Type:  ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                ³LOCATION³Type Description³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      0 ³     LOBYTE     ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      1 ³     OFFSET     ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      2 ³     BASE       ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      3 ³     POINTER    ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      4 ³     HIBYTE     ³
                ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
T-MODULE Record Format (24 of 38) -- Fixup
                         T-MODULE Record Format -- Fixup

LOCAT:  ÚÄÂÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
        ³ ³    ³ ³LOCATION³LE/LIDATA³
        ³1³Mode³0³  Type  ³  Offset ³
        ÃÄÅÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
        ³1³ 1  ³1³   3    ³    10   ³
        ÃÄÁÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´
        ³low byte          high byte³
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

LE/LIDATA Offset --
  This field is used to determine the LOCATION information for the fixup.  This
  offset is actually an offset into the last LEDATA or LIDATA record.  The
  LEDATA or LIDATA contains the base LSEG and offset information.  Note that
  for LIDATA records, each time the data at LE/LIDATA Offset is repeated, the
  fixup must occur.
T-MODULE Record Format (25 of 38) -- Fixup
                         T-MODULE Record Format -- Fixup

                    ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³LOCAT³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³     ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  2  ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

Fixup Methods:  ÚÄÂÄÄÄÄÄÂÄÂÄÂÄÄÄÄÄÄ¿
                ³F³FRAME³T³P³TARGET³  F --
                ÃÄÅÄÄÄÄÄÅÄÅÄÅÄÄÄÄÄÄ´    If F is 1 then FRAME is a thread, else
                ³1³  3  ³1³1³  2   ³    FRAME is the FRAME method.
                ÃÄÁÄÄÄÄÄÁÄÁÄÁÄÄÄÄÄÄ´
                ³      byte        ³  T --
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    If T is 1 then TARGET is a thread, else
                                        TARGET is the TARGET method.
FRAME --
  This is either the FRAME method (F=0) or a FRAME thread (F=1).
TARGET --
  This is either the TARGET method (T=0) or a TARGET thread (T=1).
P --
  If P=0 then the primary TARGET methods are used and the TARGET Offset field
  will be present.
T-MODULE Record Format (26 of 38) -- Fixup
                         T-MODULE Record Format -- Fixup

                    ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³LOCAT³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³     ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  2  ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

FRAME INDEX --
  Depending on the FRAME method, this is either a Segment, Group, or External
  INDEX.  This will be present only when a FRAME thread is not used (F=0).

TARGET INDEX --
  Depending on the TARGET method, this is either a Segment, Group, or External
  INDEX.  This will be present only when a TARGET thread is not used (T=0).

TARGET Offset --
  The TARGET is TARGET Offset bytes from the Segment, Group, or External given
  by TARGET INDEX.
T-MODULE Record Format (27 of 38) -- T-MODULE End (MODEND)
                 T-MODULE Record Format -- T-MODULE End (MODEND)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³End ³ Start  ³Check³
                        ³8AH³Length³Type³Address ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³ 1  ³variable³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

End Type:  ÚÄÄÄÄÄÄÄÄÄÂÄÂÄ¿  Attribute:  ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
           ³Attribute³0³1³              ³Attribute³Description               ³
           ÃÄÄÄÄÄÄÄÄÄÅÄÅÄ´              ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
           ³    2    ³5³1³              ³    0    ³Non-main, no Start Address³
           ÃÄÄÄÄÄÄÄÄÄÁÄÁÄ´              ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
           ³    byte     ³              ³    1    ³Non-main, Start Address   ³
           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ              ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                                        ³    2    ³Main, no Start Address    ³
                                        ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                                        ³    3    ³Main, Start Address       ³
                                        ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
T-MODULE Record Format (28 of 38) -- T-MODULE End (MODEND)
                 T-MODULE Record Format -- T-MODULE End (MODEND)


    Start Address:  ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

The above fields work exactly the same as they do in a FIXUPP record.  The
start address is computed from the FRAME and TARGET specified above.  The
initial CS is the FRAME NUMBER of the FRAME, and the initial IP is
TARGET - FRAME.
T-MODULE Record Format (29 of 38) -- Comment Record (COMENT)
                T-MODULE Record Format -- Comment Record (COMENT)

                      ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                      ³   ³Record³Comment³        ³Check³
                      ³88H³Length³ Type  ³Comment ³ Sum ³
                      ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                      ³ 1 ³  2   ³  2    ³variable³  1  ³
                      ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Comment Type:  ÚÄÄÄÄÄÂÄÄÄÄÂÄÂÄÄÄÄÄ¿
               ³Purge³List³0³Class³
               ÃÄÄÄÄÄÅÄÄÄÄÅÄÅÄÄÄÄÄ´
               ³  1  ³ 1  ³6³  8  ³
               ÃÄÄÄÄÄÁÄÄÄÄÁÄÁÄÄÄÄÄ´
               ³       word       ³
               ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Purge --
  COMENT record should not be deleted by utilities which can delete comments
  (Purge=1).

List --
  COMENT record should not be listed by utilities which can list comments
  (LIST=1).
T-MODULE Record Format (30 of 38) -- Comment Record (COMENT)
                T-MODULE Record Format -- Comment Record (COMENT)

ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Class³                            Description                             ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 129 ³Do not do a default library search.                                 ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 157 ³Memory model information is in the Comment field.                   ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 158 ³Use the "DOSSEG" ordering.                                          ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 159 ³Library name is in the Comment field.                               ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 161 ³Codeview (registered trademark of Microsoft) information is present.³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 162 ³Pass 1 of linker can stop processing T-MODULE here.                 ³
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
T-MODULE Record Format (31 of 38) -- Communal Definition
             T-MODULE Record Format -- Communal Definition (COMDEF)

            ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
            ³   ³      ³Symbol³Type ³Far or Near³ Communal ³Check³
            ³B0H³Length³ NAME ³INDEX³ Communal  ³   Size   ³ Sum ³
            ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
            ³ 1 ³  2   ³ NAME ³INDEX³     1     ³ variable ³  1  ³
            ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Symbol NAME --
  This is the name of the communal symbol.  It is placed in the list of
  external symbols just as if it were an EXTDEF record.  If a PUBDEF record
  with the same Symbol NAME is encountered, it overrides the COMDEF.

Type INDEX --
  This is ignored.

Far or Near Communal --
  Far communals have a 61H coded here.  Near communals have a 62H coded here.

The ultimate size of the communal is the largest communal.
T-MODULE Record Format (32 of 38) -- Communal Definition
             T-MODULE Record Format -- Communal Definition (COMDEF)

For near communals, Communal Size is:  ÚÄÄÄÄÄ¿
                                       ³SIZE ³
                                       ³VALUE³
                                       ÃÄÄÄÄÄ´
                                       ³VALUE³
                                       ÀÄÄÄÄÄÙ

For far communals, Communal Size is:   ÚÄÄÄÄÄÂÄÄÄÄÄ¿
                                       ³COUNT³SIZE ³
    The size of the communal is:       ³VALUE³VALUE³
                                       ÃÄÄÄÄÄÅÄÄÄÄÄ´
      COUNT VALUE * SIZE VALUE         ³VALUE³VALUE³
                                       ÀÄÄÄÄÄÁÄÄÄÄÄÙ

Near communals go in DGROUP.  Far communals go in HUGE_BSS and are packed as
compactly as possible into PSEGs of no more than 64K.
T-MODULE Record Format (33 of 38) -- Forward Reference Fixups
           T-MODULE Record Format -- Forward Reference Fixups (FORREF)

                 ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                 ³   ³      ³Segment³    ³      ³ Fixup  ³Check³
                 ³B2H³Length³ INDEX ³Size³Offset³ Data   ³ Sum ³
                 ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                 ³ 1 ³  2   ³ INDEX ³ 1  ³  2   ³variable³  1  ³
                 ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                         ÀÄÄÄrepeatedÄÄÄÄÙ

Segment INDEX --
  The Forward Reference Fixup is to be applied to the LSEG element whose index
  into the SEGDEF list is Segment INDEX.
Size --
  This specifies the size of the Fixup Data fields.  The Fixup Data fields
  are a byte when Size = 0, a word when Size = 1, or a DWORD when Size = 2.
Offset --
  This is the Offset into the LSEG specified by Segment Index where the fixup is
  applied.
Fixup Data --
  This value is added at the specified Offset.

Note:  The FORREF record may occur before the LE/LIDATA records which load data
       into the LSEG.  Therefore, FORREFs must be applied at fixup time.
T-MODULE Record Format (34 of 38) -- Local External Definition
          T-MODULE Record Format -- Local External Definition (MODEXT)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³External³Type ³Check³
                        ³B4H³Length³  NAME  ³INDEX³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³  NAME  ³INDEX³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄÄÄrepeatedÄÄÄÙ


The fields of the MODEXT record function just like the EXTDEF record except that
the external is local to this T-MODULE only.  The External NAME is included in
the list of externals.
T-MODULE Record Format (35 of 38) -- Local Public Definition
           T-MODULE Record Format -- Local Public Definition (MODPUB)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³Group³Segment³FRAME ³Public³Public³Type ³Check³
           ³B6H³Length³INDEX³ INDEX ³NUMBER³ NAME ³Offset³INDEX³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³INDEX³ INDEX ³ 0-2  ³ NAME ³  2   ³INDEX³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄÄÄÄÄrepeatedÄÄÄÄÄÄÙ

The fields of the MODPUB record function just like the PUBDEF record except that
the public symbol is local to this T-MODULE only.
T-MODULE Record Format (36 of 38) -- Line Number (LINNUM)
                 T-MODULE Record Format -- Line Number (LINNUM)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³          ³Check³
                        ³94H³Length³   Data   ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    1     ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄrepeatedÄÙ

The LINNUM record is ignored by the linker.
T-MODULE Record Format (37 of 38) -- Type Definition (TYPDEF)
               T-MODULE Record Format -- Type Definition (TYPDEF)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³          ³Check³
                        ³8EH³Length³   Data   ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    1     ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄrepeatedÄÙ

The TYPDEF record is ignored by the linker.
T-MODULE Record Format (38 of 38) -- Record Order
                     T-MODULE Record Format -- Record Order

Object modules are parsed via recursive descent as defined below:

     t_module::      THEADR seg_grp {component} modtail

     seg_grp::       {LNAMES | SEGDEF | EXTDEF} {TYPDEF | EXTDEF | GRPDEF}

     component::     data | debug_record

     data::          content_def | thread_def | COMDEF | TYPDEF | PUBDEF |
                     EXTDEF | FORREF | MODPUB | MODEXT

     debug_record::  LINNUM

     content_def::   data_record {FIXUPP}

     thread_def::    FIXUPP  (containing only thread fields)

     data_record::   LIDATA | LEDATA

     modtail::       MODEND
Primary Internal Data Structure
                         Primary Internal Data Structure

ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿             ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Segment #1 ÃÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 Contents ³
ÀÄÄÄÄÄÂÄÄÄÄÄÄÙ             ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      ³                         ³
      ³                         
      ³                    ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      ³                    ³ LSEG #2 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #2 Contents ³
      ³                    ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      ³                         
      ³                        ///
      
ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿             ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Segment #2 ÃÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 Contents ³
ÀÄÄÄÄÄÂÄÄÄÄÄÄÙ             ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      ³                         ³
      ³                         
      ³                    ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                          ³ LSEG #2 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #2 Contents ³
     ///                   ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                
                               ///
Temp File
                                  Temp File

The linker employs a temp file to save information which can only be processed
after all the T-MODULEs have been processed.  The information which must be
saved is:

                        	  Fixups
                        	  LE/LIDATA for common LSEGS
                        	  FORREF records

The temp file is deleted when processing is complete.
Library File Format (1 of 4)
                               Library File Format

  library_file::    header_page {t_modules} trailer_page {directory_pages}

  header_page ::    ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄ¿
                    ³   ³Record³Directory³Directory³          ³ ³
                    ³F0H³Length³ Offset  ³ Pages   ³   Pad    ³0³
                    ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄ´
                    ³ 1 ³  2   ³   4     ³   2     ³    1     ³1³
                    ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÙ
                                          (prime)  ÀÄrepeatedÄÙ

  t_modules ::      The t_modules are as described above except a pad is added
                    after the MODEND record to make the t_module occupy a
                    full page. The page size is the header_page Record Length
                    + 3.

  trailer_page ::   ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄ¿
                    ³   ³Record³          ³ ³
                    ³F1H³Length³   Pad    ³0³
                    ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄ´
                    ³ 1 ³  2   ³    1     ³1³
                    ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÙ
                               ÀÄrepeatedÄÙ
Library File Format (2 of 4) -- Directory
                        Library File Format -- Directory


  directory_pages ::  public_pointer_array {public_entry} pad

Notes:  A directory page is always 512 bytes.  A directory page can contain
        up to 37 public entries.

public_pointer_array --
  This is a 38 byte array which is used to point into the public_entry field.
  To determine where public i is located in the directory page, take the ith
  byte of the public_pointer_array (relative 0) and multiple it by 2.  That
  byte will be the beginning of the public_entry for ith public in the
  directory.  The 38th entry is used to point to the beginning of the free
  space in directory page.

public_entry ::  ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿
                 ³ Public³Starting³
                 ³ NAME  ³  Page  ³
                 ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄ´
                 ³ NAME  ³   2    ³
                 ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÙ
Library File Format (3 of 4) -- Finding a Public
                     Library File Format -- Finding a Public

The library directory employs a two-tiered hashing scheme to store public
names in its directory.  A detailed description of the algorithm is given later,
but for now the following general aspects of the algoritm are useful.  To start
the search, you need to know which directory page to start searching, and if
you don't find it in that page, which directory page to search next.  Once in
a directory page, you have to know which entry to use to begin the search and
which entry to search next if it was not found.

We will call the four required values STARTING_PAGE, DELTA_PAGE, STARTING_ENTRY,
and DELTA_ENTRY.  The detail on how to compute these values is give later.

Start with directory page STARTING_PAGE.  On that page, examine public_entry
STARTING_ENTRY.  There are three cases.  This could be the public symbol you
desire, in which case you are done.  The public_pointer_array for this entry
could be zero, in which case the symbol is not in the library.  Or, this the
public symbol at STARTING_ENTRY could be some other public symbol.  In this
case, add DELTA_ENTRY (modulo 37) to the STARTING_ENTRY and examine that
public entry.  Since there are at most 37 entries in any directory page,
examine no more than 37 entries in any given page.  If you have tried all
entries on a page, proceed to the next page by adding DELTA_PAGE (modulo
Directory_Pages) to STARTING_PAGE and continue the process.  When you move to
a new page, continue processing the public entries where you left off.
Library File Format (4 of 4) -- Finding a Public
                     Library File Format -- Finding a Public

To compute the STARTING_PAGE, DELTA_PAGE, STARTING_ENTRY, and DELTA_ENTRY, view
a NAME field as if it were an array of bytes containing the public name:

                        ÚÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄ//ÄÂÄÄÄÄÄÄ¿
            NAMEÄÄÄÄÄÄÄ>³Length³byte³byte³byte³    ³ byte ³
                        ÃÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄ//ÄÅÄÄÄÄÄÄ´
                        ³  1   ³ 1  ³ 1  ³ 1  ³    ³  1   ³
                        ÃÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄ//ÄÅÄÄÄÄÄÄ´
            indexÄÄÄÄÄÄ>³  0   ³ 1  ³ 2  ³ 3  ³    ³Length³
                        ÀÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÁÄÄÄÄÁÄ//ÄÁÄÄÄÄÄÄÙ

Then, the following code define the values:
STARTING_PAGE, DELTA_PAGE, STARTING_ENTRY, DELTA_ENTRY  0;
for i  0 .. Length-1
 STARTING_PAGESTARTING_PAGE+(NAME[i] or 20H) xor (<<STARTING_PAGE);
 DELTA_PAGEDELTA_PAGE+(NAME[Length-i+1] or 20H) xor (<<DELTA_PAGE);
 STARTING_ENTRYSTARTING_ENTRY+(NAME[Length-i+1] or 20H) xor (>>STARTING_ENTRY);
 DELTA_ENTRYDELTA_ENTRY+(NAME[i] or 20H) xor (>>DELTA_ENTRY);
end for;
if DELTA_ENTRY = 0 then DELTA_ENTRY1;
if DELTA_PAGE = 0 then DELTA_PAGE1;
Note:  << is circular shift left twice and >> is circular shift right twice.
